# import ehrql libraries
from ehrql import create_dataset, show
from ehrql.tables.tpp import patients, practice_registrations, ons_deaths
from ehrql.tables.raw.tpp import repeat_medications, medications

# get codelists
import codelists

# create dataset from dummy tables generated by ehrQL
dataset = create_dataset()

# define start of period of interest
index_date = "2025-01-01"

# require registration to exist 
has_registration = practice_registrations.for_patient_on(
    index_date
).exists_for_patient()

# require patient to be alive/dead: use ONS record if present, otherwise use GP record
death_date = ons_deaths.date.when_null_then(patients.date_of_death)
was_alive = death_date.is_after(index_date) | death_date.is_null()

# define population
dataset.define_population(has_registration & was_alive)

# configure the dummy data
dataset.configure_dummy_data(
    population_size = 50
)

# restrict repeat medications table to after start date
repeat_medications = repeat_medications.where(repeat_medications.date.is_on_or_after(index_date))

# restrict medications table also
medications = medications.where(medications.date.is_on_or_after(index_date))

# # get number of occasions start_date and consultation date are same per patient
# dataset.concordant_dates = (
#     repeat_medications.where(repeat_medications.date == repeat_medications.start_date)
#     .date
#     .count_distinct_for_patient()
# )

# # get number of occasions start_date and consultation date are different per patient
# dataset.discordant_dates = (
#     repeat_medications.where(repeat_medications.date != repeat_medications.start_date)
#     .date
#     .count_distinct_for_patient()
# )

# # get T/F about statin repeat
# dataset.statins = (
#     repeat_medications.where(repeat_medications.dmd_code.is_in(codelists.statins))
#     .exists_for_patient()
# )

# # count how many times this appears
# dataset.statins_count = (
#     repeat_medications.where(repeat_medications.dmd_code.is_in(codelists.statins))
#     .date
#     .count_distinct_for_patient()
# )

# # similarly, get the count from the medications table
# dataset.statins_counts_med_tab = (
#     medications.where(medications.dmd_code.is_in(codelists.statins))
#     .date
#     .count_distinct_for_patient()
# )

# # get T/F about codeine-containing meds repeat
# dataset.codeine = (
#     repeat_medications.where(repeat_medications.dmd_code.is_in(codelists.codeine))
#     .exists_for_patient()
# )

# # count how many times this appears
# dataset.codeine_count = (
#     repeat_medications.where(repeat_medications.dmd_code.is_in(codelists.codeine))
#     .date
#     .count_distinct_for_patient()
# )

# # similarly, get the count from the medications table
# dataset.codeine_counts_med_tab = (
#     medications.where(medications.dmd_code.is_in(codelists.codeine))
#     .date
#     .count_distinct_for_patient()
# )

# show(dataset)

statins_med = (
    medications.where(medications.dmd_code.is_in(codelists.statins))
    .sort_by(medications.date)
)
statins_rep = (
    repeat_medications.where(repeat_medications.dmd_code.is_in(codelists.stains))
    .sort_by(repeat_medications.date)
)
codeine_med = (
    medications.where(medications.dmd_code.is_in(codelists.codeine))
    .sort_by(medications.date)
)
codeine_rep = (
    repeat_medications.where(repeat_medications.dmd_code.is_in(codelists.codeine))
    .sort_by(repeat_medications.date)
)
concordant_dates = (
    repeat_medications.where(repeat_medications.date == repeat_medications.start_date)
    .date
)
discordant_dates = (
    repeat_medications.where(repeat_medications.date != repeat_medications.start_date)
    .date
)

selected_medications_dict = {
    "statins_med": statins_med,
    "statins_rep": statins_rep,
    "codeine_med": codeine_med,
    "codeine_rep": codeine_rep
}

# # Count all medication status
# # This will add 6 x 28 = 168 new columns
# for desc, selected_medications in selected_medications_dict.items():
#     for status in range(29):
#         count_med_status_query = selected_medications.where(
#             selected_medications.medication_status.is_in([status])
#         ).count_for_patient()
#         dataset.add_column(f"{desc}_status{status}", count_med_status_query)